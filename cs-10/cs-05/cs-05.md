# 함수형 프로그래밍

다음 체크포인트는 학습 목표를 위해서 스스로 확인하는 단위일 뿐이다.
평가를 위한 것이 아니라 스스로 빠짐없이 학습했는지 확인하기 위한 것이다.
단지 체크포인트를 통과하기 위해서 학습하는 것이 아니기 때문에 이것을 목표로 학습하지 않는다.
학습을 하고 나서 스스로 점검하는 용도로만 활용하자.

다음 중에 완료한 항목을 체크하세요
ClassifierAlpha 함수형 리팩토링
PrimeAlpha 함수형 리팩토링
순수 함수 구현 (참조투명성 + 불변성)
클로저 활용
고차 함수 활용

### 스스로 확인할 사항

다음 사항을 스스로 추가로 학습해보고, 다른 사람의 글이나 자료를 기반으로 자기만의 표현으로 정리한다.
본인이 작성한 내용을 gist에 올리고 링크를 연결해도 좋습니다.

클로저 closure에 대해 학습하고 정리한다. _
예제 코드가 있다면 더 좋다. 리뷰할 때는 다른 언어와 차이점도 비교한다.
a
순수함수 pure function에 대해 학습하고 정리한다. _
예제 코드가 있다면 더 좋다.
a
고차 함수 higher-order function에 대해 학습하고 정리한다. \*
예제 코드가 있다면 더 좋다. 언어별로 다른 점을 비교해보자.
a

### 다같이 확인할 사항

다음 주제에 대해 각자 해결 방법을 찾아보고, 그룹내에 다른 사람의 의견을 확인하고 다양한 접근 방식이 있는지 확인한다.
하나의 답을 찾기 위한 것이 아니라, 다양한 관점에서 여러 해결 방법을 학습하기 위한 방법이다.
본인이 작성한 내용을 gist에 올리고 링크를 연결해도 좋습니다.
프로그래밍 패러다임이 무엇인지 알아보고, 왜 필요한지 토론한다. _
객체지향 패러다임과 함수형 패러다임 공통점과 차이점을 토론한다. _

### 한번에 하나씩만

### 기본 함수만 사용해보자

### 메서드만 정의하고, 변수에 담기

[함수형 프로그래밍이란?](https://godsenal.com/posts/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80/)
[함수형 언어, 5분만에 개념 순삭!(feat. 절차지향, 객체지향) - 디모의 5분 코딩상식](https://www.youtube.com/watch?v=FCH9ufdKxWE)
[함수형 프로그래밍이 뭔가요? - 얄팍한 코딩사전](https://www.youtube.com/watch?v=jVG5jvOzu9Y)
Closure - 생활코딩

[JavaScript로 함수형 프로그래밍 배우기 - Anjana Vakil - JSUnconf](https://www.youtube.com/watch?v=e-5obm1G_FY&feature=youtu.be)

### 함수가 순수해야됨

### 함수를 인풋으로 받을 수 있음

### 반복문을 피해라(대체제, map, reduce, filter)

- 리스트 뿐만이 아니라?
- 샌드위치 사진

### Use immutable data

---

### 꼬리에 꼬리를 물고 가도록 해보자

### 퓨어 함수라면 외부로부터 종속되어 있지 않기 때문에 응당 혼자서도 잘 작동해야겠지

### 먼저 한줄만 가져와보자.

```js
  factors() {
    var factorSet = new Set();
    // for문 안을 먼저 수정해보자
    for (var pod = 1; pod <= Math.sqrt(this.number); pod++) {
      if (this.isFactor(pod)) {
        factorSet.add(pod);
        factorSet.add(this.number / pod);
      }
    }
    return factorSet;
  }
```

### Array를 구해내는게 관건인 것 같다.

```js
podArr = (num) => {
  let podRaccoon = { length: Math.sqrt(num) };
  return Array.from(podRaccoon, (_, i) => i + 1);
};

podArr(10);

// expected output: [1, 2, 3]
```

### 이렇게 해봤다. 혼자서도 작동할까?

![screenshot002](https://user-images.githubusercontent.com/70361152/104885028-ad324f80-59aa-11eb-8aa0-cf4a21ec52c5.png)

### 원하는대로 작동한다. 바로 `return`해볼까

```js
podArr = (num) => Array.from({ length: Math.sqrt(num) }, (_, i) => i + 1);

podArr(10);

// output: [1, 2, 3]
```

### 여기까지는 잘 작동한다.

### 이제 다시 `ClassifierAlpha` 클래스로 돌아왔다.

### 다음 단계는 `podArr`의 요소 중 `isFactor`가 `true`인 요소를 찾아야 한다.

### `filter`을 써봤다.

```js
filterPodArr = (num) => this.podArr(num).filter((pod) => this.isFactor(num, pod));

var alpha1 = new ClassifierAlpha(10);

console.log(alpha1.filterPodArr(10));

// output: [1, 2, 3]
```

### 여기까지는 잘 작동한다.

### 이제 `for`문을 통해 `factorSet`에 반복적으로 `add`해 주던 값을 반복문 없이 세팅을 하는게 좋겠다.

### 어떻게 해야 좋지...

### `reduce`를 써서 `Set` 객체에 넣어봤다.

```js
functionalFactors = (num) =>
  this.filterPodArr(num).reduce((acc, cur) => {
    acc.add(cur);
    acc.add(num / cur);
    return acc;
  }, new Set());

var alpha1 = new ClassifierAlpha(10);

console.log(alpha1.functionalFactors(10));

// expected output: Set(4) { 1, 10, 2, 5 }
// output: Set(6) { 1, 10, 2, 5, 3, 3.3333333333333335 }
```

### `Set`가 무의미하게 됐다. 왜지...

### 이제보니 `isFactor`를 수정을 안했다. 수정해보자.

### 사실 `filterPodArr`는 제대로 작동이 안되고 있는거였다..

```js
  isFactor(number, potentialFactor) {
    return this.number % potentialFactor == 0;
  }
  // isFactor(potentialFactor) {
  //   return this.number % potentialFactor == 0;
  // }

  // expected output: [1, 2]
  // output: [1, 2]
```

### `isFactor`의 역할은 `podArr`의 요소가 `number`로 나누어 떨어지는가를 확인하는 것이기 때문에, `10 % 3`은 `false`가 되어 `filter`됐어야 했다.

### 자 이제 여기까지 합체시켜보자.

```js
functionalFactors = (num) =>
  Array.from({ length: Math.sqrt(num) }, (_, i) => i + 1)
    .filter((pod) => this.isFactor(num, pod))
    .reduce((acc, cur) => {
      acc.add(cur);
      acc.add(num / cur);
      return acc;
    }, new Set());

var alpha1 = new ClassifierAlpha(10);

console.log(alpha1.functionalFactors(10));

// expected output: Set(4) { 1, 10, 2, 5 }
// output: Set(4) { 1, 10, 2, 5 }
```

### 이제 함수형 프로그래밍으로 작성된 `functionalFactors`로 기존의 `factors`를 대체시켜도 될 것 같다.
